\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\@writefile{toc}{\contentsline {chapter}{\numberline {1}Bit\IeC {\'a}cora 1}{5}{chapter.1}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {paragraph}{\\A continuaci\IeC {\'o}n realizaremos una breve descripci\IeC {\'o}n de lo visto durante la primera clase. Vimos primero lo que es un sistema operativo, un sistema que administra el hardware de una computadora y que permite la interacci\IeC {\'o}n entre \IeC {\'e}ste y el usuario. Existen varios sistemas operativos, entre los que destacan Windows, MacOs, Android y iOs cada uno creado para distintos prop\IeC {\'o}sitos y distintas arquitecturas de computadora. Sin embargo, uno de los m\IeC {\'a}s singulares hasta el momento es un sistema operativo llamado Linux, creado por Linus Torvalds, el cual es un sistema de c\IeC {\'o}digo libre, es decir, un sistema en el que cualquier persona, sin un estricto \IeC {\'a}nimo de lucro, puede tener libre acceso al c\IeC {\'o}digo del sistema para as\IeC {\'\i } mejorarlo y colaborar en su desarrollo. En consecuencia, al no ser necesario un \IeC {\'a}nimo de lucro, este tipo de sistemas operativos pueden ser usados por cualquier usuario sin tener que pagar necesariamente una licencia por \IeC {\'e}l. De esta forma, Linux puede ser un sistema operativo gratuito, que es respaldado por miles de desarrolladores que d\IeC {\'\i }a a d\IeC {\'\i }a hacen de esta plataforma una mejor opci\IeC {\'o}n frente a otros sistemas.\\Ahora bien, como se dej\IeC {\'o} entrever, una de las caracter\IeC {\'\i }sticas de Linux, que puede ser una de sus principales ventajas o uno de sus mayores inconvenientes, es que, al tener much\IeC {\'\i }simos desarrolladores, los objetivos o intereses perseguidos a la hora de desarrollar la plataforma no siempre es homog\IeC {\'e}nea, lo que se traduce en el surgimiento de una gran variedad de versiones de este sistema, cuya \IeC {\'u}nica propiedad en com\IeC {\'u}n es el kernel, o el c\IeC {\'o}digo interno sobre el cual se monta la interfaz gr\IeC {\'a}fica, las caracter\IeC {\'\i }sticas y las aplicaciones. Cada una de estas versiones es conocida como una distribuci\IeC {\'o}n de Linux, que va a tener ciertas caracter\IeC {\'\i }sticas que la har\IeC {\'a}n especial, como puede ser su gran poder de procesamiento, su bajo consumo de recursos, su gran versatilidad para manejar distintos tipos de hardware, etc. No obstante, si bien hay una gran variedad de distribuciones, es sabido que existen tres distribuciones principales, de las cuales se derivan las dem\IeC {\'a}s: Ubuntu, Debian y Fedora. Estas versiones son sistemas operativos fuertes por s\IeC {\'\i } mismos, aunque al ser tan vers\IeC {\'a}tiles no satisfacen todas las necesidades de todos los usuarios, pues para aquellos que deseen un sistema ligero que les permita adentrarse poco a poco al entorno de Linux, estos sistemas no son la mejor opci\IeC {\'o}n. Un ejemplo de este \IeC {\'u}ltimo tipo de sistema es Slax, un sistema operativo basado en Debian que apenas si consume 100 MB de memoria en su estado m\IeC {\'a}s b\IeC {\'a}sico, lo cual hasta lo vuelve ideal para usarse con las PC m\IeC {\'a}s antiguas. Entonces, hay una versi\IeC {\'o}n de Linux para todos los intereses de los usuarios.\\Algo a tener en cuenta es que las distribuciones de Linux son sistemas operativos que, en mayor o menor medida, requieren de cierto conocimiento en el manejo de su Shell interno, que es un int\IeC {\'e}rprete de comandos, un programa que est\IeC {\'a} a la espera de una instrucci\IeC {\'o}n para ejecutarla. Gr\IeC {\'a}ficamente es una pantalla negra en la que se teclean los comandos y se navega \IeC {\'u}nicamente con el teclado, un proceder que evoca al manejo de las computadoras en los principios de los a\IeC {\~n}os ochenta. En Linux, este Shell se conoce como Bash y sus comandos sirven para administrar y utilizar el sistema, as\IeC {\'\i } como para navegar por sus directorios y visualizar sus archivos. Si bien la lista de comandos disponibles puede ser demasiado extensa, podemos resumirla en los comandos m\IeC {\'a}s promientes o esenciales:\\}{6}{section*.3}}
\@writefile{toc}{\contentsline {paragraph}{\\As\IeC {\'\i }, con estos comandos se puede checar informaci\IeC {\'o}n general del sistema, navegar a trav\IeC {\'e}s de los directorios, crear y administrar archivos, as\IeC {\'\i } como descargar aplicaciones.}{7}{section*.4}}
\@writefile{toc}{\contentsline {chapter}{\numberline {2}Bit\IeC {\'a}cora 2}{9}{chapter.2}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {paragraph}{\\En la clase 2 finalmente dejamos las charlas y en el taller de ciencias de la computaci\IeC {\'o}n 1 comenzamos a trabajar en el entorno de Linux. Los que trajimos nuestro propio computador, instalamos el sistema operativo y ejecutamos los comandos "apt-get update" y "apt-get upgrade" para actualizar la biblioteca de donde se descargan aplicaciones. A continuaci\IeC {\'o}n debimos realizar un paso importante para la din\IeC {\'a}mica del curso, que consisti\IeC {\'o} en crear un repositorio p\IeC {\'u}blico en el servidor git con el objeto de subir nuestros trabajos para su revisi\IeC {\'o}n. El procedimiento es sencillo en realidad, primero hay que crear la cuenta en github.com, con nuestro n\IeC {\'u}mero de cuenta como nombre de usuario y nuestro correo de ciencias como el correo de la cuenta. Una vez creada la cuenta, se tiene que acceder a nuestros repositorios en github.com y entonces hacer clic en nuevo. Entonces se pedir\IeC {\'a} la confirmaci\IeC {\'o}n de nuestro correo, con lo que se nos enviar\IeC {\'a} un mensaje al correo para as\IeC {\'\i } verificarlo. Una vez hecho esto, se nos permitir\IeC {\'a} crear el repositorio, s\IeC {\'o}lo habr\IeC {\'a} que nombrarlo. En mi caso particular, lo nombr\IeC {\'e} como TallerHC. Ahora viene la parte m\IeC {\'a}s complicada, que es sincronizar ese repositorio con el Linux de nuestro computador. En Bash, hay que escribir el comando "apt-get install git", que instalar\IeC {\'a} la aplicaci\IeC {\'o}n de git. A continuaci\IeC {\'o}n, hay que escribir "git init", que iniciar\IeC {\'a} la aplicaci\IeC {\'o}n, para entonces darnos de alta en la aplicaci\IeC {\'o}n con nuestro correo y nombre de usuario, para lo cual escribimos los comandos "git config --global user.email "correo"" y "git config --global user.name "NombreDeUsuario"". Una vez registrada la cuenta que queremos sincronizar, tenemos que clonar el repositorio de git que ya creamos en el servidor (TallerHC), en la carpeta de nuestra preferencia. Para ello, vamos a github.com y nos dirigimos al repositorio reci\IeC {\'e}n creado, donde encontraremos una opci\IeC {\'o}n que dice "clonar o descargar". Damos clic ah\IeC {\'\i } y copiamos la url que se nos presenta. Ahora nos dirigimos en Bash a la carpeta deseada y escribimos el comando "git clone "Direcci\IeC {\'o}nQueCopiamos"" con lo que el repositorio completo se descargar\IeC {\'a} a la carpeta deseada. Con esto estaremos preparados para empezar a guardar informaci\IeC {\'o}n en la carpeta descargada y as\IeC {\'\i } sincronizarla con el repositorio en git. Una vez se hayan guardado archivos en la carpeta TallerHC, para subirlos al servidor hay que ir en Bash a la carpeta de nuestro repositorio y escrbir "git add *" para que los archivos nuevos que no se hayan sincronizado previamente se preparen para la subida. Entonces hay que hacer un comentario de lo que vamos a subir, para ello escribimos el comando "git commit", donde se nos presentar\IeC {\'a} una secci\IeC {\'o}n para escribir la rese\IeC {\~n}a. En el caso de Slax, se presiona F2 para guardar el comentario y F10 para salir de la secci\IeC {\'o}n. Una vez hecho esto, se proceder\IeC {\'a} a subir los nuevos archivos, con el comando "git push". El sistema indicar\IeC {\'a} si se realiz\IeC {\'o} bien el proceso o no. Ahora bien, se puede checar previamente si existen archivos pendientes de sincronizarse con el servidor, para lo cual se utilizar\IeC {\'a} el comando "git status" el cual indica si hay archivos que no han sido sincronizados y si estos ya est\IeC {\'a}n en el proceso de sincronizarse. En el caso de que no haya, simplemente indicar\IeC {\'a} que el \IeC {\'a}rbol del directorio se encuentra limpio. Por otra parte, es posible que lo que se quiera hacer es descargar los archivos del servidor para actualizar el directorio que tenemos en nuestra computadora. Para ello, se puede usar "git status" para comprobar si existen archivos por descargar y en el caso afirmativo usamos "git pull" para la sincronizaci\IeC {\'o}n de descarga.\\De esta manera, en esta clase nos familiarizamos m\IeC {\'a}s en el entorno de Linux, y si bien hubo problemas para seguir los pasos en la ejecuci\IeC {\'o}n de las actividades, el simple hecho de seguirlos fue de mucha utilidad para dejar de tener como extra\IeC {\~n}o a un sistema que es usado por much\IeC {\'\i }simos desarrolladores por su caracter\IeC {\'\i }stica intr\IeC {\'\i }nseca de seguridad, versatilidad y apertura de la informaci\IeC {\'o}n.}{10}{section*.5}}
\@writefile{toc}{\contentsline {chapter}{\numberline {3}Bit\IeC {\'a}cora 3}{11}{chapter.3}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {paragraph}{\\Se checaron una vez m\IeC {\'a}s los pasos para crear y sincronizar un repositorio de git. Como ejercicio se crearon en la carpeta TallerHC la carpeta Clases, que contendr\IeC {\'a} los archivos creados durante el curso y que estar\IeC {\'a} dividida en dos carpetas m\IeC {\'a}s: Latex y Programas. La primera carpeta contendr\IeC {\'a} nuestras bit\IeC {\'a}coras de cada d\IeC {\'\i }a y los archivos de Latex que creemos, mientras que programas contendr\IeC {\'a} los documentos para Python que creemos por igual. Para esta creaci\IeC {\'o}n se hizo uso del comando "mkdir" en Bash, donde se hizo la observaci\IeC {\'o}n que si se escrib\IeC {\'\i }a "mkdir -p "ruta de directorios" se pod\IeC {\'\i }a crear m\IeC {\'a}s de una carpeta por comando, estableciendo una ruta parental. A continuaci\IeC {\'o}n se cre\IeC {\'o} un archivo de nombre Clase03.txt que se guard\IeC {\'o} en la carpeta de Latex, en el cual se anotaron los pasos para crear un repositorio en git. Para hacer este archivo se utiliz\IeC {\'o} el comando vi en Bash, el cual lanza la aplicaci\IeC {\'o}n Vim, un editor de texto plano que se encuentra dentro del mismo Shell. El comando a ejecutar desde la carpeta de Latex es "vi Clase03.txt" el cual abre Vim para la edici\IeC {\'o}n del texto. Mostrar\IeC {\'a} el archivo vac\IeC {\'\i }o y para comenzar a editarlo es necesario teclear la letra "i". Se escribe el documento y una vez finalizada la edici\IeC {\'o}n se pulsa la tecla "esc" para dejar de editarlo. Ahora, para guardar y salir, se debe escribir el doble punto ":" seguido de "wq" (sin comillas) para entonces pulsar la tecla enter. El sistema regresar\IeC {\'a} a Bash, y se podr\IeC {\'a} comprobar que el documento creado existe en la carpeta actual. Se puede usar el comando "cat Clase03.txt" para checar de forma sucinta lo escrito. Ahora bien, si se desea salir sin guardar, se debe escribir ":q!", con lo cual el sistema no guardar\IeC {\'a} los cambios y, en su caso, no crear\IeC {\'a} el archivo. A continuaci\IeC {\'o}n, se debi\IeC {\'o} subir los directorios y el nuevo archivo al repositorio de git, para ello se usaron los comandos "git add *", "git commit" y "git push", tal y como se describi\IeC {\'o} en la bit\IeC {\'a}cora anterior.\\Despu\IeC {\'e}s de esta pr\IeC {\'a}ctica, se procedi\IeC {\'o} a explicar un poco el procedimiento para resolver un problema, un paso esencial para programar en cualquier lenguaje de computadora. B\IeC {\'a}sicamente, primero hay que definir el problema a resolver, es decir, hay que entenderlo debidamente, o de otra manera no sabr\IeC {\'\i }amos siquiera qu\IeC {\'e} es lo que hay que resolver. A continuaci\IeC {\'o}n es preciso analizarlo y delimitarlo, hay que entederlo en base a su contexto y sus fundamentos. Despu\IeC {\'e}s llega el momento de buscar soluciones al problema, buscar posibles aproximaciones, de forma vaga e intuitiva, que nos alumbrar\IeC {\'a}n un poco el camino a seguir. Esto s\IeC {\'o}lo ser\IeC {\'a} un primer paso, pues ahora que se tienen las posibles soluciones se necesita descrbirlas con detalle, en aras de hacerlas consistentes y comprobar si son efectivas en realidad. As\IeC {\'\i }, una vez que se tiene una soluci\IeC {\'o}n espec\IeC {\'\i }fica, llega la hora de dar un paso m\IeC {\'a}s y volverla general, que no s\IeC {\'o}lo resuelva el problema en algunas circunstancias, sino que sea \IeC {\'u}til en muchas situaciones para su mejor implementaci\IeC {\'o}n. De esta manera, se tendr\IeC {\'a} un soluci\IeC {\'o}n fuerte y resistente en la pr\IeC {\'a}ctica.}{12}{section*.6}}
\@writefile{toc}{\contentsline {chapter}{\numberline {4}Bit\IeC {\'a}cora 4}{13}{chapter.4}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {paragraph}{En la cuarta clase, comenzamos a ver el entorno de Python. La versi\IeC {\'o}n de Python que debemos usar es Python 2, en mi caso, utilizar\IeC {\'e} la versi\IeC {\'o}n 2.7.13. Muchas distribuciones de Linux tienen preinstalada alguna versi\IeC {\'o}n de Python, para combrobarlo basta con ir a Bash y escrbibir "python" como comando y presionar dos veces la tecla tabulador. Ah\IeC {\'\i } se mostrar\IeC {\'a}n todas las versiones de Python ya instaladas en el sistema. Ahora bien, lo que est\IeC {\'a} instalado es el lenguaje \IeC {\'u}nicamente, no se encuentra instalado alg\IeC {\'u}n editor adecuado para hacer scripts de programas escritos en ese lenguaje. Si bien es posible escrbir un programa de Python en el editor de texto preinstalado en el sistema, es recomendable usar un editor adecuado, cuya interfaz sea amigable para escribir un programa, es decir, que tenga elementos que permitan detectar errores, completar par\IeC {\'e}ntesis o comandos, resaltar con colores determinados comandos y palabras reservadas para distinguirles f\IeC {\'a}cilmente. En el caso de la clase, se utilizar\IeC {\'a} el editor Idle, que es un IDE o entorno de desarrollo integrado, que a fin de cuentas es una aplicaci\IeC {\'o}n que proporciona servicios para facilitar el desarrollo de software. Para instalar Idle, se utiliz\IeC {\'o} el comando "apt install idle", el cual se encarg\IeC {\'o} de todo el proceso. Ahora bien, es posible correr Python desde Bash, basta con ejecutar el comando "python", pero con este m\IeC {\'e}todo se accede al int\IeC {\'e}rprete de una forma muy b\IeC {\'a}sica, a nivel consola, no muy apto para escribir y guardar scripts. En vez de ello, simplemente se va a ejecutar el comando idle, el cual abrir\IeC {\'a} una ventana con la consola de Python, pero desde la que se podr\IeC {\'a}n abrir archivos nuevos y existentes, editarlos, guardarlos y ejecutarlos c\IeC {\'o}modamente desde una interfaz gr\IeC {\'a}fica. As\IeC {\'\i }, una vez conocido nuestro nuevo entorno de trabajo, pasamos a averiguar c\IeC {\'o}mo resolver un problema desde la perspectiva vista de la clase pasada. El problema en cuesti\IeC {\'o}n fue c\IeC {\'o}mo calcular la posici\IeC {\'o}n de una pelota en un momento determinado, cuando es lanzada a una velocidad inicial hacia arriba. Esto es claramente un problema que se resuelve con la f\IeC {\'o}rmula de la ca\IeC {\'\i }da libre, donde la posici\IeC {\'o}n deseada se expresa como:}{14}{section*.7}}
\@writefile{toc}{\contentsline {paragraph}{\IeC {\textquestiondown }Pero c\IeC {\'o}mo se har\IeC {\'\i }a un programa en Python que calcule, por ejemplo, la posici\IeC {\'o}n del objeto cuando la velocidad inicial es 34${\begingroup m\endgroup \over s}$, en el segundo cinco despu\IeC {\'e}s de que fuera lanzado y considerando a la aceleraci\IeC {\'o}n de la gravedad como 9.81${\begingroup m\endgroup \over s^2}$? Para ello tuvimos que aprender el uso en Python de las operaciones b\IeC {\'a}sicas, que son multiplicaci\IeC {\'o}n, suma, divisi\IeC {\'o}n, resta y potencia, en vistas de poder escribir la f\IeC {\'o}rmula deseada en un programa. A continuaci\IeC {\'o}n, en Idle creamos el programa Ejemplo1Pelota.py mediante la herramienta Nuevo archivo del men\IeC {\'u} Archivo y lo guardamos en la carpeta de Programas, con lo cual escribimos el programa declarando el valor de las variables que representar\IeC {\'\i }an a la velocidad inicial, a la gravedad y al tiempo, y las combinamos en la f\IeC {\'o}rmula deseada, cuyo valor lo asignamos a la variable posici\IeC {\'o}n, que ser\IeC {\'\i }a la que ser\IeC {\'\i }a imprimida por el programa mediante el comando print. As\IeC {\'\i }, se guard\IeC {\'o} el programa y se presion\IeC {\'o} la tecla f5 para que fuera ejecutado en idle, el cual arroj\IeC {\'o} un resultado incorrecto, producto de un peque\IeC {\~n}o detalle que hay que tener en cuenta a la hora de programar en esta versi\IeC {\'o}n del lenguaje: el programa arroja los resultados conforme al tipo de variable que se le da. Es decir, si en una operaci\IeC {\'o}n se le ordena sumar dos n\IeC {\'u}meros enteros, el programa arrojar\IeC {\'a} como resultado un n\IeC {\'u}mero entero. Esto representa un problema a la hora de dividir, pues si se le ordena dividir dos n\IeC {\'u}meros enteros, el programa arrojar\IeC {\'a} un n\IeC {\'u}mero entero, sin importar si el resultado no lo era. Para corregir este problema, basta con ingresar alguno de los n\IeC {\'u}meros que componen la divisi\IeC {\'o}n como un n\IeC {\'u}mero de tipo flotante, es decir, como un n\IeC {\'u}mero que tenga decimales, aunque estos sean cero. Python distingue a 2 como n\IeC {\'u}mero entero y a 2.0 como n\IeC {\'u}mero flotante, simplemente es el tipo de variable en el que se guarda la informaci\IeC {\'o}n. De esta manera, se corrigi\IeC {\'o} el error en el programa y en esta ocasi\IeC {\'o}n arroj\IeC {\'o} el resultado deseado al ejecutarlo. Result\IeC {\'o} un gran avance en el curso, al grado de que hasta se dej\IeC {\'o} como tarea hace un programa que resolviera el c\IeC {\'a}lculo de alguna otra f\IeC {\'o}rmula matem\IeC {\'a}tica. En mi caso, escog\IeC {\'\i } el teorema de Pit\IeC {\'a}goras.}{14}{section*.8}}
\@writefile{toc}{\contentsline {chapter}{\numberline {5}Bitacora 5}{15}{chapter.5}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {paragraph}{\\Retomando lo visto y hecho la clase anterior, aprendimos primero un uso m\IeC {\'a}s elaborado de la instrucci\IeC {\'o}n print de Python. Para ello vimos un nuevo tipo de variable, que es la variable cadena, o string. Esta variable almacena texto, guarda una secuencia de caracteres sin alg\IeC {\'u}n valor l\IeC {\'o}gico. La manera de declarar una cadena es poner el texto a declarar entre comillas, es decir, "Esto es una cadena.". Se puede guardar con alg\IeC {\'u}n nombre espec\IeC {\'\i }fico, tal y como se guarda una variable de tipo entero. Ahora bien, con el comando print, se puede mandar a imprimir una cadena sin mayores inconvenientes, s\IeC {\'o}lo se escribe print "cadena". Esto es \IeC {\'u}til en programas complejos, para solicitar informaci\IeC {\'o}n o mostrar informaci\IeC {\'o}n que ayude a los usuarios a navegar por el sistema. Sin embargo, las cadenas tambi\IeC {\'e}n pueden volverse \IeC {\'u}tiles en programas simples, en el momento en que se desea editar el resultado de alg\IeC {\'u}n c\IeC {\'a}lculo hecho en el programa. En vez de s\IeC {\'o}lo imprimir el n\IeC {\'u}mero que da daterminada operaci\IeC {\'o}n, con una cadena se puede mandar a imprimir el n\IeC {\'u}mero con alg\IeC {\'u}n comentario, que lo haga entendible a aqu\IeC {\'e}l que lo lea. En el programa hecho en la clase anterior, con una cadena resulta sencillo mandar a imprimir la posici\IeC {\'o}n del objeto en el segundo cinco de una forma legible: "La posici\IeC {\'o}n de la pelota tras 5 segundos de haber sido lanzada es...", lo cual adem\IeC {\'a}s le confiere cierta elegancia. Para lograr esto es necesario hacer uso de cierto comodines que se colocan en los lugares de la cadena donde queremos imprimir las variables. Se utiliza el s\IeC {\'\i }mbolo \% seguido de una letra que indica el tipo de variable que desea imprimirse. A continuaci\IeC {\'o}n, al final de la cadena, se insertan las variables a imprimir, en el orden en que se fueron colocando sus comodines respectivos y en el formato \%(variable1, variable2, etc...). Ahora bien, respecto a estas letras, hay muchas y diversas, pero para mencionar algunas \%E es para formato cient\IeC {\'\i }fico, \%s para cadena, \%g para imprimir la variable en su expresi\IeC {\'o}n m\IeC {\'a}s corta posible, \%f para imprimir una variable en una expresi\IeC {\'o}n flotante, usualmente se usa de la forma \%a.bf, donde a es el n\IeC {\'u}mero m\IeC {\'\i }mimo de caracteres a imprimir y b el n\IeC {\'u}mero de decimales a imprimir. Si a no est\IeC {\'a} determinado, se imprime el valor de la variable sin alterar. Tambi\IeC {\'e}n tenemos \%e para formato cient\IeC {\'\i }fico de n\IeC {\'u}meros peque\IeC {\~n}os o \%d para n\IeC {\'u}mero enteros. Se realiz\IeC {\'o} un programa, de nombre EjemplosPrint.py para mostrar m\IeC {\'a}s comodines y sus usos. Ahora, como se dej\IeC {\'o} entrever, es posible imprimir variables de alg\IeC {\'u}n tipo determinado en un formato espec\IeC {\'\i }fico, como en el caso de las variables flotantes, aunque el mencionado archivo ya se encarga de mostrar m\IeC {\'a}s ejemplos. As\IeC {\'\i }, finalmente retornamos al caso del programa de la ca\IeC {\'\i }da libre, y haciendo un nuevo programa de nombre Ejemplo1Pelota\_05.py se edit\IeC {\'o} el resultado mediante una cadena. El c\IeC {\'o}digo que imprime la cadena es: "print 'La posici\IeC {\'o}n de la pelota en el t=\%g es \%.2f' \%(t,y)".\\Finalmente pasamos a ver una funci\IeC {\'o}n diferente de Python: Las funciones. \IeC {\'E}stas son una manera de crear "acciones" en Python que pueden invocarse en un momento deseado, sin tener que volver a implementar el c\IeC {\'o}digo completo. Por ejemplo, en el caso del programa de ca\IeC {\'\i }da libre, puede implementarse una funci\IeC {\'o}n que calcule la posici\IeC {\'o}n del objeto no s\IeC {\'o}lo para valores fijos, sino para los valores que deseemos sin tener que escribir la f\IeC {\'o}rmula en todo momento. Para esto se usa el comando def seguido del nombre que deseemos poner a la funci\IeC {\'o}n, seguido de las variables que ser\IeC {\'a}n usadas para hacer nuestro c\IeC {\'a}lculo entre par\IeC {\'e}ntesis y separadas por comas, todo seguido por dos puntos. Entonces nosotros debemos escribir debajo nuestra operaci\IeC {\'o}n, guard\IeC {\'a}ndola en una variable que ser\IeC {\'a} devuelta por la funci\IeC {\'o}n con el comando return. la variable devuelta por "return" determinar\IeC {\'a} el tipo de variable que ser\IeC {\'a} otorgado a la funci\IeC {\'o}n, y podr\IeC {\'a} utilizarse como si de una variable normal se tratar\IeC {\'a}. As\IeC {\'\i } pues, en el programa de la ca\IeC {\'\i }da libre, podemos escribir su funci\IeC {\'o}n de la siguiente manera:\\\\def CaidaLibre(tiempo, VelocidadInicial):\\\hspace  *{1cm}posicion = v0*t - 1.0/2*9.81*t**2\\\hspace  *{1cm}return(posicion)\\\\Esto permitir\IeC {\'a} introducir los valores que deseen para el tiempo y la velocidad inicial, simplemente con invocar la funci\IeC {\'o}n por su nombre e incluir en el orden establecido los valores entre par\IeC {\'e}ntesis. Si se corre el archivo una vez, incluso idle es capaz de invocar la funci\IeC {\'o}n desde donde sea que se haya guardado el archivo.\\El anterior sin duda fue un gran avance, dej\IeC {\'a}ndose como tarea el implementar una funci\IeC {\'o}n de la tarea pasada. Sin embargo, la clase a\IeC {\'u}n no terminaba y se comenz\IeC {\'o} a ver Latex, que es un sistema de composici\IeC {\'o}n de textos, que permite crear documentos de alta calidad y que es usado por muchos matem\IeC {\'a}ticos para escribir sus libros o los resultados de sus investigaciones. Para ello, al igual que Python, se instal\IeC {\'o} un editor de textos con el comando apt, de nombre texstudio, y en mi caso se instal\IeC {\'o} el lenguaje de Latex bajo el nombre de texlive, pues muchas otras distribuciones de Linux ya incluyen el lenguaje por defecto. Ahora bien, creamos un documento nuevo de nombre Ejercicio01.tex, con el que aprendimos la estructura b\IeC {\'a}sica de todo documento de Latex, as\IeC {\'\i } como algunos comandos de edici\IeC {\'o}n. Aprendimos los comandos para comenzar el documento, para crear un t\IeC {\'\i }tulo, para que el sistema reconozca caracteres de espa\IeC {\~n}ol, para poner negritas o cambiar de color el texto y para enumerar un listado, lo cual ser\IeC {\'a} esencial para crear las bit\IeC {\'a}coras del curso.}{17}{section*.9}}
\@writefile{toc}{\contentsline {chapter}{\numberline {6}Bit\IeC {\'a}cora 6}{19}{chapter.6}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {paragraph}{En python se vio el comando if, el cual permite que el sistema ejecute una instrucci\IeC {\'o}n con determinadas condiciones. B\IeC {\'a}sicamente la estructura es if (condici\IeC {\'o}n): y debajo se escribe la instrucci\IeC {\'o}n con identaci\IeC {\'o}n. Como ejemplos calculamos el valor absoluto de un n\IeC {\'u}mero, en el que si era negativo lo devolv\IeC {\'\i }a positivo y si era positivo lo devolv\IeC {\'\i }a igual. Como ejercicio se dej\IeC {\'o} hacer diana.py y como tarea una extensi\IeC {\'o}n del mismo. En Latex vimos como poner secciones y s\IeC {\'\i }mbolos matem\IeC {\'a}ticos.}{19}{section*.10}}
\@writefile{toc}{\contentsline {chapter}{\numberline {7}Bit\IeC {\'a}cora 7}{21}{chapter.7}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {paragraph}{Comenzamos a ver el comando while, el cual permite que una instrucci\IeC {\'o}n se repita varias veces hasta que deje de cumplirse una condici\IeC {\'o}n determinada. B\IeC {\'a}sicamente se escribe while(condici\IeC {\'o}n): y debajo se pone de forma indentada la instrucci\IeC {\'o}n. Este comando es demasiado \IeC {\'u}til si se sabe utilizar. Se pueden realizar sumas de una sucesi\IeC {\'o}n de n\IeC {\'u}meros, restas, e incluso se pueden poner con condicionales if, aumentando su poder. De esta forma, hicimos el ejercicio Ulam.py, en vistas de practicar. Usualmente se utiliza un contador en estos comandos, el cual lleva la cuenta de las veces que se repite la instrucci\IeC {\'o}n, y al llegar a un n\IeC {\'u}mero determinado de veces hace que se detenga el ciclo. No obstante, la condici\IeC {\'o}n no necesariamente tiene que ser de naturaleza n\IeC {\'u}merica, puede ser un valor booleano, es decir, de verdadero o falso, el cual es determinado desde dentro del ciclo mismo. Esto permite que las posibilidades se extiendan, y sea diferente a otras opciones de ciclos, los cuales se ver\IeC {\'a}n m\IeC {\'a}s adelante.}{21}{section*.11}}
\@writefile{toc}{\contentsline {chapter}{\numberline {8}Bit\IeC {\'a}cora 8}{23}{chapter.8}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {paragraph}{Volvimos a checar el ciclo while e if, con los cuales se dejaron 10 ejercicios de tarea a realizar. El primero era calcular el MCD de dos n\IeC {\'u}meros, el segundo era calcular el tiempo en que se encuentra el objeto que es lanzado en el ejercicio de tiro vertical de la pelota, el tercero era convertir de grados Celsius a Farenheit y viceversa, el cuarto era dada una posici\IeC {\'o}n en la sucesi\IeC {\'o}n de Fibonacci, calcular su valor, el quinto era calcular la suma de los primeros n n\IeC {\'u}meros, el sexto era calcular el promedio de 10 n\IeC {\'u}meros, el s\IeC {\'e}ptimo era calcular el mismo promedio de diez n\IeC {\'u}meros, pero tambi\IeC {\'e}n determinar el n\IeC {\'u}mero m\IeC {\'a}s peque\IeC {\~n}o y el m\IeC {\'a}s grande, y por \IeC {\'u}ltimo, los \IeC {\'u}ltimos tres ten\IeC {\'\i }amos que idearlos nosotros, siempre y cuando tuvieran ciclo while e if.\\Despu\IeC {\'e}s vimos una nueva manera de imprimir valores en cadenas. Una copia del c\IeC {\'o}digo la introducir\IeC {\'e} aqu\IeC {\'\i }:}{23}{section*.12}}
\@writefile{toc}{\contentsline {chapter}{\numberline {9}Bit\IeC {\'a}cora 9}{25}{chapter.9}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {paragraph}{Se revisaron los ejercicios encargados en la tarea del d\IeC {\'\i }a anterior. Se aclararon dudas y dieron consejos. Se vio un nuevo ejercicio, en el cual se defin\IeC {\'\i }a una funci\IeC {\'o}n en la que se ingresaba un n\IeC {\'u}mero, y si era par se divid\IeC {\'\i }a entre 2 y si era impar se multiplicaba por 3 y se le sumaba 1, tras lo cual se repet\IeC {\'\i }a la operaci\IeC {\'o}n hasta que finalmente el n\IeC {\'u}mero ingresado se redujera a 1. Esto claramente es una pr\IeC {\'a}ctica de los comandos while e if. Aqu\IeC {\'\i } est\IeC {\'a} la transcripci\IeC {\'o}n del c\IeC {\'o}digo del ejercicio:}{25}{section*.13}}
\@writefile{toc}{\contentsline {paragraph}{Tambi\IeC {\'e}n checamos c\IeC {\'o}mo importar comandos desde el sistema operativo para ser usados en Python. S\IeC {\'o}lo se trata de escribir en Idle el comando "from os import "comandos"", con los cuales se podr\IeC {\'a}n utilizar en Linux desde Python. Despu\IeC {\'e}s de esto vimos Latex, en el cual checamos arreglos como tablas, alineamientos y matrices. He aqu\IeC {\'\i } una transcripci\IeC {\'o}n:}{25}{section*.14}}
\@writefile{toc}{\contentsline {chapter}{\numberline {10}Bit\IeC {\'a}cora 10}{27}{chapter.10}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {paragraph}{En la clase 10 empezamos a ver listas en Python, que son una estructura de datos bastante importante para este lenguaje de programaci\IeC {\'o}n. Si ha de definirse en lenguaje coloquial de alguna manera, es un conjunto ordenado, el cual consta de elementos que tienen una posici\IeC {\'o}n en dicho conjunto. Para construirlo, basta con poner los elementos en el orden deseado, separados por comas, y encerrarlos dentro de corchetes. "[Esto, es, una, lista, de, 7, elementos]". Puede asign\IeC {\'a}rsele un nombre y guardarla como si se tratase de una variable cualquiera. Al fin y al cabo es un objeto, al igual de una cadena o un n\IeC {\'u}mero entero, s\IeC {\'o}lo que con propiedades diferentes. Ahora bien, divergiendo un poco en el tema, existe un comando llamado bool, el cual permite determinar si una variable de alg\IeC {\'u}n tipo determinado est\IeC {\'a} vac\IeC {\'\i }a o guarda alg\IeC {\'u}n valor relacionado con nulidad, dependiendo de su tipo de variable. Si no es nulo, devuelve verdadero; si lo es devuelve falso. Entonces, en el caso de n\IeC {\'u}meros enteros, ser\IeC {\'a} nulo su valor si es cero, en el caso de cadenas, ser\IeC {\'a} nulo si la cadena est\IeC {\'a} vac\IeC {\'\i }a. En el caso de las listas, si efectivamente est\IeC {\'a} vac\IeC {\'\i }a la lista, es decir, si es igual a []. Ahora bien, tambi\IeC {\'e}n se chec\IeC {\'o} otro comando aplicable \IeC {\'u}nicamente a las listas, el comando len, el cual devuelve el n\IeC {\'u}mero de elementos de una lista en particular. Es decir, si ponemos len([a,b,c,d]), len ser\IeC {\'a} igual a 4. La anterior es la forma de invocar la instrucci\IeC {\'o}n. Tambi\IeC {\'e}n vimos algunos m\IeC {\'e}todos de las listas, el .append("valor"), que agrega un elemento a la cola de la lista, el .insert(posicion, valor), en cual agrega en la posici\IeC {\'o}n deseada de la lista un valor dado, desplazando a la derecha el valor que ocupaba esa posici\IeC {\'o}n. Tambi\IeC {\'e}n vimos .pop() y .pop(posicion) el cual quita, en el primer caso, de la lista el \IeC {\'u}ltimo elemento o, en el segundo caso, el elemento cuya posici\IeC {\'o}n se determina. Este valor quitado se puede guardar como variable. Se vio el m\IeC {\'e}todo .extend("lista") en el cual a una lista dada se le pueden agregar los elementos de otra lista, que quedar\IeC {\'\i }an a la cola de la primera. Ahora, la manera en que se determinan las posiciones de los elementos de una lista es simple, el primer elemento ser\IeC {\'a} el elmento 0, y el \IeC {\'u}ltimo ser\IeC {\'a} el elemento len(lista)-1, lo que indica que todos los elementos se enumerar\IeC {\'a}n del 0 al len(lista).1. Si se quiere imprimir o guardar un elemento determinado de una lista, basta con escribir lista[posicion], lo cual regresar\IeC {\'a} el elemento solicitado. Ahora bien, es posible meter una lista dentro de otra, como si fuera un elemento cualquiera, por lo que si se quiere imprimir o guardar un elemento de esa lista anidada, basta con poner lista[posicionDeLaListaAnidada][Elemento], lo cual devolver\IeC {\'a} el valor sin problemas.//Ahora, se pas\IeC {\'o} a ver otro ciclo de Python, el ciclo for, el cual permite que se repita un proceso por cada elemento de una lista determinada. He aqu\IeC {\'\i } una transcrpici\IeC {\'o}n de los c\IeC {\'o}digos vistos en clase:}{28}{section*.15}}
\@writefile{toc}{\contentsline {chapter}{\numberline {11}Bit\IeC {\'a}cora 11}{31}{chapter.11}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {paragraph}{Se prosigui\IeC {\'o} revisando el tema de listas y el ciclo for. Se checaron dudas de la tarea y se revisaron nuevos temas. En particular, se dej\IeC {\'o} como tarea hacer un programa que calculara la suma superior y la inferior de un conjunto de \IeC {\'a}reas dado por la funci\IeC {\'o}n -6x3+5x2+2x+12, evaluada en n intervalos cuyas distancias entre s\IeC {\'\i } ser\IeC {\'\i }an multiplicadas por la funci\IeC {\'o}n de cada borde, a manera de calcular sumas de Rieman finitas. Para ello, el usuario deber\IeC {\'\i }a ingresar los intervalos deseados y el intervalo de la funci\IeC {\'o}n a evaluar.\\Tambi\IeC {\'e}n se pas\IeC {\'o} a checar en Latex el uso de los documentos libro, en el que checamos c\IeC {\'o}mo poner \IeC {\'\i }ndices, c\IeC {\'o}mo hacer cap\IeC {\'\i }tulos y poner bibliograf\IeC {\'\i }a, secciones y v\IeC {\'\i }nculos con hyperref. He aqu\IeC {\'\i } una transcripci\IeC {\'o}n:}{31}{section*.16}}
\@writefile{toc}{\contentsline {chapter}{\numberline {12}Bit\IeC {\'a}cora 12}{35}{chapter.12}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {paragraph}{En esta clase seguimos reforzando el tema de listas y for. En especial, pasamos a checar c\IeC {\'o}mo hacer una lista directamente con un ciclo for, sin tener que escribir todo los elementos. B\IeC {\'a}sicamente s\IeC {\'o}lo se escribe primero la condici\IeC {\'o}n o f\IeC {\'o}rmula que va a tener cada elemento en t\IeC {\'e}rminos de lo segundo que se escribe, que es una lista (que simplemente puede ser un range()). As\IeC {\'\i }, si se quiere crear una lista de grados Farenheit desde una lista de grados Celsius basta con determinarla as\IeC {\'\i }: [i*1.8 + 32 for i in gradosC]. Tambi\IeC {\'e}n podr\IeC {\'\i }a ser posible hacer una lista de listas de esta manera, simplemente determinar primero el formato para despu\IeC {\'e}s poner los elementos a ingresar en el formato: [[C,F] for C,F in zip(gradosC,gradosF)], donde zip es la funci\IeC {\'o}n que permite discernir los elementos de las dos listas. Vimos c\IeC {\'o}mo es posible guardar los elementos de una lista sin tener que declarar uno a uno los elementos a guardar, basta con que escribamos lista[x:y] para imprimir los elementos de lista desde la posici\IeC {\'o}n x a la y-1. Es posible hacer esto con las sublistas, s\IeC {\'o}lo basta con poner el segundo \IeC {\'\i }ndice. Para finalizar Python, realizamos el documento tablas, cuya transcripci\IeC {\'o}n es la siguiente:}{35}{section*.17}}
\@writefile{toc}{\contentsline {paragraph}{Ahora pasamos a ver en Latex el uso de Beamer, que es una especie de powerpoint, un tipo de documento que permite hacer presentaciones en forma de diapositivas. Vimos como abrir diapositivas nuevas, como pasar de una diapositiva a otra con transblindshorizontal, c\IeC {\'o}mo poner t\IeC {\'\i }tulos en la diapositiva con frametitle y como poner temas predeterminados. He aqu\IeC {\'\i } la transcricpi\IeC {\'o}n de lo visto:}{35}{section*.18}}
\@writefile{toc}{\contentsline {chapter}{\numberline {13}Bit\IeC {\'a}cora 13}{39}{chapter.13}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {paragraph}{En esta clase se comenz\IeC {\'o} a ver un tema importante en la programaci\IeC {\'o}n, que es el tema de la recursi\IeC {\'o}n. B\IeC {\'a}sicamente, una funci\IeC {\'o}n recursiva es aquella que se utiliza a s\IeC {\'\i } misma para definirse. Con esto, se puede realizar un ciclo a manera de while o de for, s\IeC {\'o}lo que de una manera que no recurre a gastar memoria con un comando de ciclo. Ciertamente es un tema dif\IeC {\'\i }cil de entender al principio, pero aqu\IeC {\'\i } hay algunos ejemplos:}{39}{section*.19}}
\@writefile{toc}{\contentsline {paragraph}{Como puede apreciarse, todo programa de recursi\IeC {\'o}n requiere de una "base" el cual es que detiene el proceso. En el programa de factorial, por ejemplo, al ingresar n, el proceso hace que n se multiplique por la siguiente ejecuci\IeC {\'o}n de la funci\IeC {\'o}n, que ser\IeC {\'\i }a n-1, y a su vez n-1 se multiplicar\IeC {\'\i }a por n-2 y as\IeC {\'\i } sucesivamente hasta llegar a 1. Al llegar a 1, el proceso devolver\IeC {\'\i }a la multiplicaci\IeC {\'o}n de todas las funciones ejecutadas, dando as\IeC {\'\i } el factorial.}{40}{section*.20}}
\@writefile{toc}{\contentsline {chapter}{\numberline {14}Bit\IeC {\'a}cora 14}{41}{chapter.14}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {paragraph}{En la pen\IeC {\'u}ltima clase, se checaron dudas sobre la tarea del d\IeC {\'\i }a anterior, que consisti\IeC {\'o} en realizar los ejercicios de la secci\IeC {\'o}n de evaluaci\IeC {\'o}n del libro Python f\IeC {\'a}cil. Eran ocho ejercicios, de los cuales el que present\IeC {\'o} m\IeC {\'a}s dudas fue el del laberinto. Consiste en lo siguiente: "Dise\IeC {\~n}e y programe un algoritmo recursivo que encuentre la salida de un laberinto, teniendo en cuenta que el laberinto se toma como entrada y que es una matriz de valores True, False, (x,y), (a,b), donde True indica uno bst\IeC {\'a}culo; False, una celda por la que se puede caminar; (x,y), el punto donde comienza a buscarse la salida y (a,b), la salida del laberinto.". Entonces, se checaron varias posibles soluciones, yo en particular realic\IeC {\'e} el algoritmo de la siguiente manera:}{41}{section*.21}}
\@writefile{toc}{\contentsline {paragraph}{Esta es el archivo de implementaci\IeC {\'o}n, el cual explica en qu\IeC {\'e} consiste y como debe introducir los datos el usuario5:}{42}{section*.22}}
\@writefile{toc}{\contentsline {chapter}{\numberline {15}Bit\IeC {\'a}cora 15}{43}{chapter.15}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {paragraph}{Al final, en esta \IeC {\'u}ltima clase, se realiz\IeC {\'o} una evaluaci\IeC {\'o}n, que consisti\IeC {\'o} en una primera parte de 30 preguntas hechas en el classroom de google, de opci\IeC {\'o}n m\IeC {\'u}ltiple, en una segunda que consisti\IeC {\'o} en escribir un texto con temas vistos que no estaban en el examen, y por \IeC {\'u}ltimo en un examen de 7 ejercicios para realizar en Python, los cuales deb\IeC {\'\i }an subirse en un carpeta llamada pr\IeC {\'a}ctica a github.}{43}{section*.23}}
