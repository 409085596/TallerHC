\relax 
\@writefile{toc}{\contentsline {paragraph}{En la cuarta clase, comenzamos a ver el entorno de Python. La versi\IeC {\'o}n de Python que debemos usar es Python 2, en mi caso, utilizar\IeC {\'e} la versi\IeC {\'o}n 2.7.13. Muchas distribuciones de Linux tienen preinstalada alguna versi\IeC {\'o}n de Python, para combrobarlo basta con ir a Bash y escrbibir "python" como comando y presionar dos veces la tecla tabulador. Ah\IeC {\'\i } se mostrar\IeC {\'a}n todas las versiones de Python ya instaladas en el sistema. Ahora bien, lo que est\IeC {\'a} instalado es el lenguaje \IeC {\'u}nicamente, no se encuentra instalado alg\IeC {\'u}n editor adecuado para hacer scripts de programas escritos en ese lenguaje. Si bien es posible escrbir un programa de Python en el editor de texto preinstalado en el sistema, es recomendable usar un editor adecuado, cuya interfaz sea amigable para escribir un programa, es decir, que tenga elementos que permitan detectar errores, completar par\IeC {\'e}ntesis o comandos, resaltar con colores determinados comandos y palabras reservadas para distinguirles f\IeC {\'a}cilmente. En el caso de la clase, se utilizar\IeC {\'a} el editor Idle, que es un IDE o entorno de desarrollo integrado, que a fin de cuentas es una aplicaci\IeC {\'o}n que proporciona servicios para facilitar el desarrollo de software. Para instalar Idle, se utiliz\IeC {\'o} el comando "apt install idle", el cual se encarg\IeC {\'o} de todo el proceso. Ahora bien, es posible correr Python desde Bash, basta con ejecutar el comando "python", pero con este m\IeC {\'e}todo se accede al int\IeC {\'e}rprete de una forma muy b\IeC {\'a}sica, a nivel consola, no muy apto para escribir y guardar scripts. En vez de ello, simplemente se va a ejecutar el comando idle, el cual abrir\IeC {\'a} una ventana con la consola de Python, pero desde la que se podr\IeC {\'a}n abrir archivos nuevos y existentes, editarlos, guardarlos y ejecutarlos c\IeC {\'o}modamente desde una interfaz gr\IeC {\'a}fica. As\IeC {\'\i }, una vez conocido nuestro nuevo entorno de trabajo, pasamos a averiguar c\IeC {\'o}mo resolver un problema desde la perspectiva vista de la clase pasada. El problema en cuesti\IeC {\'o}n fue c\IeC {\'o}mo calcular la posici\IeC {\'o}n de una pelota en un momento determinado, cuando es lanzada a una velocidad inicial hacia arriba. Esto es claramente un problema que se resuelve con la f\IeC {\'o}rmula de la ca\IeC {\'\i }da libre, donde la posici\IeC {\'o}n deseada se expresa como:}{2}}
\@writefile{toc}{\contentsline {paragraph}{\IeC {\textquestiondown }Pero c\IeC {\'o}mo se har\IeC {\'\i }a un programa en Python que calcule, por ejemplo, la posici\IeC {\'o}n del objeto cuando la velocidad inicial es 34$\frac  {m}{s}$, en el segundo cinco despu\IeC {\'e}s de que fuera lanzado y considerando a la aceleraci\IeC {\'o}n de la gravedad como 9.81$\frac  {m}{s^2}$? Para ello tuvimos que aprender el uso en Python de las operaciones b\IeC {\'a}sicas, que son multiplicaci\IeC {\'o}n, suma, divisi\IeC {\'o}n, resta y potencia, en vistas de poder escribir la f\IeC {\'o}rmula deseada en un programa. A continuaci\IeC {\'o}n, en Idle creamos el programa Ejemplo1Pelota.py mediante la herramienta Nuevo archivo del men\IeC {\'u} Archivo y lo guardamos en la carpeta de Programas, con lo cual escribimos el programa declarando el valor de las variables que representar\IeC {\'\i }an a la velocidad inicial, a la gravedad y al tiempo, y las combinamos en la f\IeC {\'o}rmula deseada, cuyo valor lo asignamos a la variable posici\IeC {\'o}n, que ser\IeC {\'\i }a la que ser\IeC {\'\i }a imprimida por el programa mediante el comando print. As\IeC {\'\i }, se guard\IeC {\'o} el programa y se presion\IeC {\'o} la tecla f5 para que fuera ejecutado en idle, el cual arroj\IeC {\'o} un resultado incorrecto, producto de un peque\IeC {\~n}o detalle que hay que tener en cuenta a la hora de programar en esta versi\IeC {\'o}n del lenguaje: el programa arroja los resultados conforme al tipo de variable que se le da. Es decir, si en una operaci\IeC {\'o}n se le ordena sumar dos n\IeC {\'u}meros enteros, el programa arrojar\IeC {\'a} como resultado un n\IeC {\'u}mero entero. Esto representa un problema a la hora de dividir, pues si se le ordena dividir dos n\IeC {\'u}meros enteros, el programa arrojar\IeC {\'a} un n\IeC {\'u}mero entero, sin importar si el resultado no lo era. Para corregir este problema, basta con ingresar alguno de los n\IeC {\'u}meros que componen la divisi\IeC {\'o}n como un n\IeC {\'u}mero de tipo flotante, es decir, como un n\IeC {\'u}mero que tenga decimales, aunque estos sean cero. Python distingue a 2 como n\IeC {\'u}mero entero y a 2.0 como n\IeC {\'u}mero flotante, simplemente es el tipo de variable en el que se guarda la informaci\IeC {\'o}n. De esta manera, se corrigi\IeC {\'o} el error en el programa y en esta ocasi\IeC {\'o}n arroj\IeC {\'o} el resultado deseado al ejecutarlo. Result\IeC {\'o} un gran avance en el curso, al grado de que hasta se dej\IeC {\'o} como tarea hace un programa que resolviera el c\IeC {\'a}lculo de alguna otra f\IeC {\'o}rmula matem\IeC {\'a}tica. En mi caso, escog\IeC {\'\i } el teorema de Pit\IeC {\'a}goras.}{3}}
